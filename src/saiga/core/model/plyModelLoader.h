/**
 * Copyright (c) 2017 Darius RÃ¼ckert
 * Licensed under the MIT License.
 * See LICENSE file for more information.
 */

#pragma once
#include "saiga/core/geometry/triangle_mesh.h"
#include "saiga/core/util/color.h"
#include "saiga/core/util/tostring.h"

#include <fstream>
#include <iostream>

namespace Saiga
{
class SAIGA_CORE_API PLYLoader
{
   public:
    struct VertexProperty
    {
        std::string name;
        std::string type;
    };



    std::vector<std::pair<int, int>> offsetType;


    int vertexSize;
    int dataStart;
    std::vector<char> data;
    std::vector<VertexProperty> vertexProperties;

    std::string faceVertexCountType;
    std::string faceVertexIndexType;

    TriangleMesh<VertexNC, uint32_t> mesh;

    int vertexCount = -1, faceCount = -1;

    PLYLoader(const std::string& file);


    int sizeoftype(std::string t);

    void parseHeader();

    void parseMeshBinary();


    template <typename VertexType, typename IndexType>
    static void save(std::string file, TriangleMesh<VertexType, IndexType>& mesh)
    {
        std::cout << "Save ply " << file << std::endl;
        std::vector<char> data;

        std::vector<std::string> header;

        header.push_back("ply");

        header.push_back("format binary_little_endian 1.0");
        header.push_back("comment generated by lib saiga");


        header.push_back("element vertex " + to_string(mesh.vertices.size()));

        header.push_back("property float x");
        header.push_back("property float y");
        header.push_back("property float z");

        header.push_back("property float red");
        header.push_back("property float green");
        header.push_back("property float blue");

        header.push_back("element face " + to_string(mesh.faces.size()));
        header.push_back("property list uchar int vertex_indices");

        header.push_back("end_header");


        for (auto str : header)
        {
            data.insert(data.end(), str.begin(), str.end());
            data.push_back('\n');
        }

        int dataStart = data.size();

        int vertexSize = 3 * sizeof(float) + 3 * sizeof(float);
        data.resize(data.size() + vertexSize * mesh.vertices.size());
        char* ptr = data.data() + dataStart;
        for (auto v : mesh.vertices)
        {
            float* f = (float*)ptr;
            f[0]     = v.position.x;
            f[1]     = v.position.y;
            f[2]     = v.position.z;

            float* c = (float*)(f + 3);
            //            c[0] = 255;
            //            c[1] = 255;
            //            c[2] = 255;

            //            vec3 col = Color::srgb2linearrgb(v.color);
            c[0] = v.color.x;
            c[1] = v.color.y;
            c[2] = v.color.z;


            ptr += vertexSize;
        }



        int faceStart = data.size();
        int faceSize  = 3 * sizeof(int) + 1;
        data.resize(data.size() + faceSize * mesh.faces.size());
        ptr = data.data() + faceStart;
        for (auto f : mesh.faces)
        {
            ptr[0]    = 3;
            int* fptr = (int*)(ptr + 1);
            fptr[0]   = f.v1;
            fptr[1]   = f.v2;
            fptr[2]   = f.v3;
            ptr += faceSize;
        }

        std::ofstream stream(file, std::ios::binary);
        if (!stream.is_open())
        {
            std::cerr << "Could not open file " << file << std::endl;
        }

        stream.write(data.data(), data.size());
    }
};


}  // namespace Saiga
