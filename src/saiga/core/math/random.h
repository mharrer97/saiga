/**
 * Copyright (c) 2017 Darius RÃ¼ckert
 * Licensed under the MIT License.
 * See LICENSE file for more information.
 */

#pragma once

#include "saiga/config.h"
#include "saiga/core/math/math.h"
#include "saiga/core/util/assert.h"

#include <vector>

namespace Saiga
{
/**
 * Simple Random numbers that are created by c++11 random engines.
 * These function use static thread local generators.
 * -> They are created on the first use
 * -> Can be used in multi threaded programs
 */
namespace Random
{
/**
 * Sets a random seed.
 * By default the seed is generated by the time.
 * Take care, that the random generator is thread local.
 * Therefore every thread has to call this method.
 */
SAIGA_CORE_API void setSeed(uint64_t seed);

SAIGA_CORE_API uint64_t getSeed();


/**
 * Returns true with a probability of 's'.
 * s must be in the range [0,1].
 */
SAIGA_CORE_API bool sampleBool(double s);

/**
 * Returns a uniform random value in the given range.
 */
SAIGA_CORE_API double sampleDouble(double min, double max);

/**
 * Uniform integer in this range.
 * Note:
 * The high-bound is inclusive!!!
 */
SAIGA_CORE_API int uniformInt(int low, int high);


/**
 * A normal-distributed random value
 */
SAIGA_CORE_API double gaussRand(double mean = 0, double stddev = 1);



/**
 * Similar to std::rand but with thread save c++11 generators
 */
SAIGA_CORE_API int rand();

/**
 * Similar to std::rand but with thread save c++11 generators
 */
SAIGA_CORE_API uint64_t urand64();

/**
 * Returns 'sampleCount' unique integers between 0 and indexSize-1
 * The returned indices are NOT sorted!
 */
SAIGA_CORE_API std::vector<int> uniqueIndices(int sampleCount, int indexSize);


}  // namespace Random



inline vec3 sphericalRand(float r)
{
    SAIGA_ASSERT(0);
    return vec3(0, 0, 0);
}


inline vec3 sampleCone(vec3 low, float f)
{
    SAIGA_ASSERT(0);
    return vec3(0, 0, 0);
}

inline float linearRand(float low, float high)
{
    return Saiga::Random::sampleDouble(low, high);
}

inline vec2 linearRand(const vec2& low, const vec2& high)
{
    return vec2(Saiga::Random::sampleDouble(low[0], high[0]), Saiga::Random::sampleDouble(low[1], high[1]));
}


inline vec3 linearRand(const vec3& low, const vec3& high)
{
    return vec3(Saiga::Random::sampleDouble(low[0], high[0]), Saiga::Random::sampleDouble(low[1], high[1]),
                Saiga::Random::sampleDouble(low[2], high[2]));
}

inline vec4 linearRand(const vec4& low, const vec4& high)
{
    return vec4(Saiga::Random::sampleDouble(low[0], high[0]), Saiga::Random::sampleDouble(low[1], high[1]),
                Saiga::Random::sampleDouble(low[2], high[2]), Saiga::Random::sampleDouble(low[3], high[3]));
}


inline vec2 diskRand(float Radius)
{
    vec2 Result(0, 0);
    float LenRadius = 0;

    do
    {
        Result    = linearRand(make_vec2(-Radius), make_vec2(Radius));
        LenRadius = length(Result);
    } while (LenRadius > Radius);

    return Result;
}
}  // namespace Saiga
